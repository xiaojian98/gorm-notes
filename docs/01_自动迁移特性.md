```go
db.AutoMigrate(&User{})
```

这行代码中的 **“自动迁移”（Auto Migration）** 是 GORM 提供的一个非常实用的功能，它的核心作用是：**自动创建或更新数据库表结构，使其与 Go 的结构体定义保持一致**。

---

### 🌟 简单来说：  
> **“自动迁移”就是让 GORM 根据你的 Go 结构体（如 `User`），自动帮你创建或修改数据库表（如 `users` 表），省去手动写 SQL 的麻烦。**

---

## 🔍 自动迁移具体做了什么？

当你调用 `AutoMigrate(&User{})` 时，GORM 会：

### ✅ 1. 如果表不存在 → **自动创建表**
- 比如 `users` 表还没创建，GORM 会根据 `User` 结构体生成建表语句并执行。

### ✅ 2. 如果表已存在 → **只添加缺失的字段（列），不会删除或修改已有列**
- 比如你之前没有 `Email` 字段，现在结构体加了，GORM 会自动 `ALTER TABLE ADD COLUMN email VARCHAR(255)`。
- 但如果你把某个字段从 `string` 改成 `int`，GORM **不会修改数据库中的列类型**（出于安全考虑）。
- 删除结构体字段 → **不会删除数据库中的列**。

---

## 🧩 举个例子

假设你有以下结构体：

```go
type User struct {
    ID       uint   `gorm:"primaryKey"`
    Name     string `gorm:"size:100"`
    Email    string `gorm:"unique"`
    Age      int
    Active   bool   `gorm:"default:true"`
}
```

执行 `AutoMigrate(&User{})` 后：

- GORM 会创建一张名为 `users` 的表（GORM 默认复数命名）。
- 包含字段：`id`, `name`, `email`, `age`, `active`。
- 并设置主键、唯一约束、默认值等。

---

## ⚠️ 自动迁移的注意事项（重要）

| 特性 | 说明 |
|------|------|
| ✅ **新增字段** | 会自动添加 |
| ❌ **修改字段类型** | 不会自动修改（如 string → int） |
| ❌ **删除字段** | 不会删除数据库中已存在的列 |
| ❌ **重命名字段** | 不会识别重命名，会当成新增+遗留旧列 |

> 所以：**AutoMigrate 适合开发阶段快速迭代，生产环境建议配合手动 SQL 迁移脚本使用（如 golang-migrate 或 goose）**。

---

## 🛠️ 它类似于其他 ORM 的“同步模型”功能

- Django: `python manage.py makemigrations` + `migrate`
- Rails: `rails db:migrate`
- TypeORM: `synchronize: true`

GORM 的 `AutoMigrate` 就是 `synchronize: true` 的作用。

---

## ✅ 什么时候使用 AutoMigrate？

| 场景 | 是否推荐 |
|------|----------|
| 学习 / 演示项目 | ✅ 强烈推荐，省时省力 |
| 开发阶段 | ✅ 推荐，快速验证模型 |
| 生产环境 | ⚠️ 谨慎使用，建议用正式迁移工具 |
| 需要精确控制表结构 | ❌ 不推荐，应手写 SQL |

---

## 📌 小结：`AutoMigrate` 的作用

| 功能 | 是否支持 |
|------|----------|
| 创建表 | ✅ |
| 添加新字段 | ✅ |
| 修改字段类型 | ❌ |
| 删除字段 | ❌ |
| 重命名字段 | ❌ |
| 创建索引、唯一约束 | ✅（通过 tag） |
| 支持外键 | ✅（需显式定义） |

---

### 💡 建议用法（带错误处理）

```go
err := db.AutoMigrate(&User{}, &Product{}, &Order{})
if err != nil {
    log.Fatal("数据库迁移失败:", err)
}
fmt.Println("✅ 数据库表已同步！")
```

---
